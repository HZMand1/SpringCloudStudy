单例模式

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。
这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

单例模式的几种实现方式
1.懒汉式，线程不安全：
public class Singleton {
  private static Singleton singleton = new Singleton();
  private Singleton (){}
  
  public static Singleton getSingleton(){
    if(null == singleton){
      singleton = new Singleton();
    }
    return singleton;
  }
}

2.懒汉式，线程安全
描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
优点：第一次调用才初始化，避免内存浪费。
缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）
public class Singleton {
  private static Singleton singleton = null;
  private Singleton(){}
  
  public static synchronized Singleton getSingleton (){
    if(null == singleton){
      singleton = new Singleton();
    }
    return singleton;
  }
}

3.双检锁/双重校验锁（DCL，即 double-checked locking）
JDK 版本：JDK1.5 起
是否 Lazy 初始化：是
是否多线程安全：是
实现难度：较复杂
描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
getInstance() 的性能对应用程序很关键。
public class Singleton (){
  private static volatile Singleton singleton = null;
  private Singleton(){}
  
  public static Singleton getSingleton (){
    if(null == singleton){
      synchronized(Singleton.class){
        if(null == singleton){
          singleton = new Singleton();
        }
      }
    }
    return singleton;
  }
}
在这里不难发现使用了关键字volatile；
volatile 在这里主要的目的是防止了jvm 的指令重排的目的
因为在 singleton = new Singleton(); 在jvm会执行三步
1.为singleton 分配内存空间
2.初始化singleton
3.把singleton指向内存空间

如果在多线程竞争不加volatile 的对象时，线程1 应经执行了1，3，但这时线程2 也进来了，他去判断null == singleton 但是
这是singleton 是不为空的，所以他就直接拿走了 singleton 但是这个singleton 是还没被初始化的，所以这是代码就会有问题。

项目上的单例模设的使用：
1.在项目启动的时候会把一些数据初始化到内存eflow 就是这么用的
2.我们项目上的一些枚举类，工具类，其实也是一个单例




