一、Http协议
1.HTTP协议，超文本传输协议，是应用最为广泛的一种传输协议，所有的WWW文件都必须遵守这个标准
2.HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）
3.HTTP是应用层的传输协议

（应用层的传输协议还包括：telnet, ssh, http, ftp, smtp, rip, BGP, ）

二、HTTP 工作原理
1.HTTP协议工作于客户端-服务端的架构之上，浏览器作为HTTP的客户端向HTTP的服务端发送所有的请求。
2.web服务器有Apache服务器，IIS服务器等（微软的产品）
3.服务器接收到请求后会返回响应消息
4.HTTP服务器的默认端口是80

另外：
1.HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，
  并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
2.HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型
  的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
3.HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。
缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

引申几个问题：
一.HTTP是无状态的协议，cookies 和 session 的产生;
1. 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，
  当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，
  用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，
  有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，
  在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，
  使用一些缓存服务比如Memcached之类的来放 Session。
  
2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。
  每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，
  第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，
  以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？
  一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？
  这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。
  这也是Cookie名称的由来，给用户的一点甜头。
  
所以，总结一下：
Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式.

二.HTTP缓存的实现
缓存的好处
1. 减少了冗余的数据传输，节省了网费。
2. 减少了服务器的负担， 大大提高了网站的性能
3. 加快了客户端加载网页的速度

如何判断缓存新鲜度
1.浏览器把缓存文件的最后修改时间通过 header ”If-Modified-Since“来告诉Web服务器。
2.浏览器把缓存文件的ETag, 通过header "If-None-Match", 来告诉Web服务器。

通过最后更新时间来确认：
1. 浏览器客户端想请求一个文档，  首先检查本地缓存，发现存在这个文档的缓存， 
获取缓存中文档的最后修改时间，通过： If-Modified-Since， 发送Request给Web服务器。
2. Web服务器收到Request，将服务器的文档修改时间（Last-Modified）: 
跟request header 中的，If-Modified-Since相比较， 如果时间是一样的， 说明缓存还是最新的， 
Web服务器将发送304 Not Modified给浏览器客户端， 告诉客户端直接使用缓存里的版本
3. 假如该文档已经被更新了。Web服务器将发送该文档的最新版本给浏览器客户端

ETag：
ETag是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果）
可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。

ETag是Web服务端产生的，然后发给浏览器客户端。浏览器客户端是不用关心Etag是如何产生的。

为什么使用ETag呢？ 主要是为了解决Last-Modified 无法解决的一些问题。
1. 某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。
2. 某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。
3. 一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了

TCP/IP
日常使用：
1.浏览器与服务器使用 TCP/IP 协议来链接因特网。
2.浏览器使用 TCP/IP 协议进入服务器，服务器使用 TCP/IP 协议来发送 HTML 到浏览器。
3.电子邮件也通过 TCP/IP 协议来发送和接收邮件。
4.因特网地址比如 "42.120.45.233" 就是一个 TCP/IP 协议。

TCP/IP 是传输层的协议;类似的一些协议还有TCP,UDP,SPX,port(65535个端口),EIGRP,OSPF

什么是TCP、IP：
1.TCP/IP 是供已连接因特网的计算机进行通信的通信协议。
2.TCP/IP 指传输控制协议/网际协议（Transmission Control Protocol / Internet Protocol）。
3.TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准

TCP 使用固定的连接：TCP 用于应用程序之间的通信。
当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。
这个请求必须被送到一个确切的地址。在双方"握手"之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。
这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。
UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。

IP 是无连接的
IP 用于计算机之间的通信。
IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。
这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。
通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。
IP 负责将每个包路由至它的目的地。

TCP/IP
TCP/IP 意味着 TCP 和 IP 在一起协同工作。
TCP 负责应用软件（比如您的浏览器）和网络软件之间的通信。
IP 负责计算机之间的通信。
TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。
IP 负责将包发送至接受者。

TCP适用于程序间的通信，TCP是通过确切的地址去访问建立通信的，我们常见的TCP建立的三次握手
为什么要三次握手：目的就是建立可靠的通信
第一次握手：Client 什么都不能确认；Server 确认了对方发送正常
第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常
第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常
所以三次握手就能确认双发收发功能都正常，缺一不可。
第一次：客户端发送标有SYN的数据包个服务端，服务端接收成功，并作出应答，返回SYN/ACK标识的数据包给客户端，这是第二次握手；
第三次是客户端接收到SYN/ACk的数据包后，作出的应答，传回ACK标识的数据包给服务端，至此整个可靠的通信建立起来。

为什么要传回 SYN：
接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

传了 SYN,为啥还要传 ACK：
双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。


为什么要四次挥手
任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。
当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

断开一个 TCP 连接则需要“四次挥手”：
客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
服务器-关闭与客户端的连接，发送一个FIN给客户端
客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1


